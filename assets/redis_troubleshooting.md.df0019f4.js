import{_ as e,c as s,o as t,a as n}from"./app.64b20f26.js";const f='{"title":"Troubleshooting issues","description":"","frontmatter":{"slug":"troubleshooting","title":"Troubleshooting issues"},"headers":[{"level":2,"title":"Debugging Data Corruption Issues","slug":"debugging-data-corruption-issues"},{"level":2,"title":"Avoiding Concurrent Usage issues","slug":"avoiding-concurrent-usage-issues"}],"relativePath":"redis/troubleshooting.md","lastUpdated":1645007721741}',a={},i=n(`<h2 id="debugging-data-corruption-issues" tabindex="-1">Debugging Data Corruption Issues <a class="header-anchor" href="#debugging-data-corruption-issues" aria-hidden="true">#</a></h2><p>An issue that can be hard to debug is if the same <code>RedisClient</code> instance is shared across multiple threads which can result in returning corrupted data. Typically, this is a result of using <code>IRedisClient</code> field in a singleton instance or sharing it as a static instance. To prevent this, each Thread that uses Redis should retrieve the redis client within a using statement, e.g:</p><div class="language-csharp"><pre><code><span class="token keyword">using</span> <span class="token class-name"><span class="token keyword">var</span></span> redis <span class="token operator">=</span> redisManager<span class="token punctuation">.</span><span class="token function">GetClient</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//...</span>
</code></pre></div><p>Unfortunately the call-site which returns the corrupted response or runtime Exception doesn&#39;t identify where else the Redis client instance was being used. To help identify where client instances are being used you can assert that the client is only used in the Thread that resolved it from the pool with:</p><div class="language-csharp"><pre><code>RedisConfig<span class="token punctuation">.</span>AssertAccessOnlyOnSameThread <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
</code></pre></div><p>This captures the Thread&#39;s StackTrace each time the client is resolved from the pool which as it adds a lot of overhead, should only be enabled when debugging connection issues.</p><p>If it does detect the client is being accessed from a different thread it will throw a <code>InvalidAccessException</code> with the message containing the different <strong>Thread Ids</strong> and the <strong>original StackTrace</strong> where the client was resolved from the pool. You can compare this with the StackTrace of the Exception to hopefully identify where the client is being improperly used.</p><h2 id="avoiding-concurrent-usage-issues" tabindex="-1">Avoiding Concurrent Usage issues <a class="header-anchor" href="#avoiding-concurrent-usage-issues" aria-hidden="true">#</a></h2><p>What to look out for in your code-base to prevent against multiple concurrent usage of a <code>IRedisClient</code> instance:</p><ul><li>Use <code>IRedisClient</code> redis instance client within a <code>using</code> statement</li><li>Never use a client instance after it has been disposed</li><li>Never use (or return) a &quot;server collection or resource&quot; (e.g. <a href="#simple-example-using-redis-lists">Redis.Lists</a>, lock) after the client has been disposed</li><li>Never keep a Singleton or <code>static</code> instance to a redis client (just the <code>IRedisClientsManager</code> factory)</li><li>Never use the same redis client in multiple threads, i.e. have each thread resolve their own client from the factory</li></ul>`,10),o=[i];function r(c,d,l,u,h,p){return t(),s("div",null,o)}var v=e(a,[["render",r]]);export{f as __pageData,v as default};
